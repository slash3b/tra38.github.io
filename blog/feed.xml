<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tariq Ali&#39;s Blog</title>
    <description>A blog dedicated to showcasing my talents</description>
    <link>tra38.github.io/blog/</link>
    <atom:link href="tra38.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 04 Jul 2015 20:13:53 -0500</pubDate>
    <lastBuildDate>Sat, 04 Jul 2015 20:13:53 -0500</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>T11 Documentation</title>
        <description>![CDATA[If you are given a powerful program, but are not given the instructions on how to use it, then the program is worthless to you. Documentation is essential to understanding code.
]</description>
        <content>&lt;p&gt;If you are given a powerful program, but are not given the instructions on how to use it, then the program is worthless to you. Documentation is essential to understanding code.&lt;/p&gt;

&lt;p&gt;Yet, documentation is neglected in the programming community. Many people tend to prioritize producing quality code over writing out how the code is supposed to work. While this may seem sensible in the short-term, in the long-term, it leads to code that is difficult for people to use. Many prospective programmers will be scared off by the complexitiy of the code, and the few that remain will spend valuable time understand what the program does instead of actually improving it.&lt;/p&gt;

&lt;p&gt;The most common form of documentation is &#39;human-readable paperwork&#39;. Examples of such paperwork includes READMEs, flowcharts, diagrams, technical manuals, and code comments. This sort of documentation is useful for people to understand the code quickly (provided the paperwork itself is well-written). However, the documentation can quickly become obsolete whenever a new update to the program is released. As a result, such documentation must be updated constantly for it to be useful. The constant strain of updating &quot;human-readable paperwork&quot; is a major reason why people tend to fear documentation altogether.&lt;/p&gt;

&lt;p&gt;But documentation is still necessary. So programmers have been exploring &lt;em&gt;alternatives&lt;/em&gt; to human-readable paperwork. These alternatives are tied directly to the source code, so whenever the code is updated, the documentation is too. These alternatives include tests, names, and self-documenting code.&lt;/p&gt;

&lt;p&gt;1) Automated tests can inform programmers about about how the code is supposed to behave. By running the tests, you can learn whether the program actually does end up behaving as it is supposed to. Since automated tests are more effective at debugging than manual testing, programmers are encouraged to have these tests anyway. So the &quot;documentation&quot; is seen as a &#39;bonus&#39;. Automated tests however only tell you what code is supposed to do, and not &lt;em&gt;why&lt;/em&gt;. You also have to still write the tests in question, and write enough tests to convey all that is essential to know about the program.&lt;/p&gt;

&lt;p&gt;2) Names convey information about a particular section of code. Whether you are naming a variable (list_of_dogs), a method (add_dog_to_list), or even a class (List), you are sending a message about what that code does (and usually more quickly than you would with a comment). Knowing what the code is supposed to do helps someone also understand how the code is supposed to work as well. However, it is extremely difficult to name variables properly and what seems like a clear variable name to the original programmer may not be to future programmers.&lt;/p&gt;

&lt;p&gt;3) Self-documenting code refers to having a consistent &quot;style guide&quot; within the code proper and ahdering to it. If a programmer is familiar with the &#39;coding conventions&#39; that the &quot;style guide&quot; promotes, then the programmer is better able to understand the program. There are innumerable style guides for every language though, so someone who is not familiar with the conventions of your guide may struggle with understanding the code. It may be difficult to convince all programmers on the team to follow the chosen &quot;style guide&quot; properly.&lt;/p&gt;

&lt;p&gt;Of course, ideally, a programmer would want all types of documentation: human-readable paperwork, automated tests, names and self-documenting code. The problem is that documentation takes time to produce, and skill to produce &lt;strong&gt;well&lt;/strong&gt;. It is essential to have good documentation, but there are many ways to do it, and some programmers will naturally graviate towards some forms of documentation while shying away from others.&lt;/p&gt;

&lt;!-- It is tempting to also have tests also play a secondary role of informing people about the code tends to be 

 &quot;self-documenting code&quot;: code that is easy for programmers to understand. The two parts of self-documenting code are variable names and automated testing.

Variable names can also serve as documentation. Variable names help to explain what is the purpose of the &#39;variable&#39; in the program. However, it is extremely difficult to name variables properly and 
 --&gt;

&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Sat, 04 Jul 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/t11-documentation.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/t11-documentation.html</guid>
        
        
      </item>
    
      <item>
        <title>C12 Fake Papers</title>
        <description>![CDATA[The most popular way of measuring the effectiveness of a scientist is by knowing how many other people 'cite' their work. If lots of people are referring to your research, then your research must therefore be good. This metric is codified as the H-Index.
]</description>
        <content>&lt;p&gt;The most popular way of measuring the effectiveness of a scientist is by knowing how many other people &#39;cite&#39; their work. If lots of people are referring to your research, then your research must therefore be good. This metric is codified as the &lt;a href=&quot;https://en.wikipedia.org/wiki/H-index&quot;&gt;H-Index&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But every metric has its own flaws. In 2010, Cyril Labbé (a computer scientist) &lt;a href=&quot;https://hal.archives-ouvertes.fr/hal-00713564/document&quot;&gt;was able to manipulate the H-Index by publishing 102 computer-generated research articles&lt;/a&gt;, many of whom cited each other. Since the papers all cited each other, the &quot;author&quot; of all these fake papers (Ike Antkare) had his H-index score boosted. The fake research papers also cited legitimate research papers to disguise the ruse.&lt;/p&gt;

&lt;p&gt;Ike Antkare soon became the 21st highest-cited scientist in the world, even outclassing Albert Einstein.&lt;/p&gt;

&lt;p&gt;The computer-generated research articles were created using &lt;a href=&quot;https://en.wikipedia.org/wiki/SCIgen&quot;&gt;SCIgen&lt;/a&gt;, a program designed to produce &quot;context-free&quot; research papers that &lt;em&gt;seems&lt;/em&gt; to be like real scientific papers, but are actually meaningless. If anybody bothered to read them, then the articles would be known to be false. The inventors of SCIgen intended to use this software to expose academic conferences and journals that accepts research papers without bothering to read them.&lt;/p&gt;

&lt;p&gt;Once Cyril Labbé exposed the ruse he made, people started reading the papers that Ike Antkare wrote. Ike Antkare lost his prestigious H-index score, as search engines began removing Ike&#39;s papers from their databases.&lt;/p&gt;

&lt;p&gt;This incident exposes a very important part about metrics...you cannot rely on only one. If you had just relied on the H-index to tell you how effective a scientist is at research, then Ike Antkare would have been a star. Only by reading Ike&#39;s papers will you be able to know the truth about Ike and avoid being fooled.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Fri, 26 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/c12-fake-papers.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/c12-fake-papers.html</guid>
        
        
      </item>
    
      <item>
        <title>E5 Writing</title>
        <description>![CDATA[Researchers want to help other people learn from them, so they write peer-reviewed papers, blog posts, etc. But researchers are also bad at writing, making it difficult for other people to learn from their research. So I was very interested in reading Steven Pinker’s article in The Chronicle of Higher Education entitled “Why Academics Stink At Writing”. Here's a summary of what Steven Pinker has written, so that you can learn why it is hard to write your own research to the general public.
]</description>
        <content>&lt;p&gt;Researchers want to help other people learn from them, so they write peer-reviewed papers, blog posts, etc. But researchers are also bad at writing, making it difficult for other people to learn from their research. So I was very interested in reading Steven Pinker’s article in The Chronicle of Higher Education entitled &lt;a href=&quot;http://chronicle.com/article/Why-Academics-Writing-Stinks/148989/&quot;&gt;“Why Academics Stink At Writing”&lt;/a&gt;. Here&#39;s a summary of what Steven Pinker has written, so that you can learn why it is hard to write your own research to the general public.&lt;/p&gt;

&lt;p&gt;There are three “general” reasons why it is difficult to understand what a researcher is saying, that Pinker acknowledges has already been discussed at length:
1) He doesn’t have anything to say, and he’s just making stuff up to hide his lack of knowledge.&lt;/p&gt;

&lt;p&gt;2) The topic is so complex that you have to use complicated language (or “jargon”) to explain it.&lt;/p&gt;

&lt;p&gt;3) Other resarchers expect him to use jargon, and if he refuses, they may reject his papers as not being serious enough.&lt;/p&gt;

&lt;p&gt;Pinker offer three other reasons:&lt;/p&gt;

&lt;p&gt;Pinker Reason #1) Researchers want to believe that the topic is complex and that only a few people can understand it. Therefore, they use “jargon” to prove their belief to themselves. The researcher does not want the reader to understand what he is saying because then it would mean the topic is easy and that the researchers has just wasted five to ten years of his life studying it.&lt;/p&gt;

&lt;p&gt;Pinker identifies these tactics used by researchers to convince themselves that the topic is difficult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Providing detailed references to previous research that was used to create his own research work.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Talking about what other researchers are currently talking about&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apologizing for his article being too controversial and difficult to understand&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Refusing to commit to any opinion on the topic, as the researcher fears that another researcher may prove his opinion wrong.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using scare-quotes to distance themselves from common idioms uttered by the general public (for example: “I think that this student is a real ‘quick-study’”).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Pinker Reason #2) The Curse of Knowledge. A researcher may be tempted to assume that the reader is as smart as him. This is a bad assumption to make, and can lead to writing that may be clear to someone as smart as the researcher, but impossible for a less-smart reader to understand. For example, the researcher may use abbreviations when the reader does not know their meaning, or casually use Latin words when a reader only knows English.&lt;/p&gt;

&lt;p&gt;Pinker Reason #3) “Chunking”. Scientists want to create container words to hold several related ideas together. This makes it easier for the researcher to organize his own thoughts, but more difficult for the reader to understand those thoughts. (For example: instead of “calling the police”, a researcher would write “law-enforcement perspective”, a container word to refer to many different ways of involving ‘law enforcement’, such as “calling the police”.)&lt;/p&gt;

&lt;p&gt;Pinker wants researchers to be able to write clearly. But writing clearly is very difficult to do. He advertises his own free downloadable booklet, “How Can You Fix Your Writing?” to help researcher out. Hopefully, I will get time to read his booklet and be able to convey his information accurately.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Thu, 18 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/e5-writing.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/e5-writing.html</guid>
        
        
      </item>
    
      <item>
        <title>T10 Writing Tests</title>
        <description>![CDATA[Testing is an important part of any programmer's life, to detect and eliminate bugs. But writing automated tests themselves can be rather costly endeavour. Not only does it take time to write your tests, but you also must make sure your tests are working properly as well. To reduce your costs, you need to reduce the amount of tests you write.
]</description>
        <content>&lt;p&gt;Testing is an important part of any programmer&#39;s life, to detect and eliminate bugs. But writing automated tests themselves can be rather costly endeavour. Not only does it take time to write your tests, but you also must make sure your tests are working properly as well. To reduce your costs, you need to reduce the amount of tests you write.&lt;/p&gt;

&lt;p&gt;According to the &lt;a href=&quot;poodr.com&quot;&gt;Practical Object-Oriented Guide to Ruby&lt;/a&gt;, automated tests should only test the &lt;em&gt;outputs&lt;/em&gt; of your code. Trying to test &lt;strong&gt;how&lt;/strong&gt; that code calcuates the output would lead to your tests breaking every time you change that code. This will waste a lot of time and energy that could be spent on other aspects of your programs. Just test the outputs of a program.&lt;/p&gt;

&lt;p&gt;POODR also suggests that you should check to see if this output ever actually gets used anywhere in the program or displayed to the user. If nobody (not even the code) gets to see this output, then it&#39;s possible that this output is unncessary. You can then delete the code that produces the output without fear, and will not have to worry about testing this code as well. You have saved yourself time and grief in maintaining the code that produces your output.&lt;/p&gt;

&lt;p&gt;Finally, POODR recommends not testing private methods. Private methods are methods that you want only the computer program to use. Since you do not want any human using them, you are free to not test these methods. It can be assumed that the program will end up using those private methods to calcuate the outputs, and if the private methods are bugged, then the resulting outputs would be wrong as well. Then the tests that you have written will indicate to you that a bug exists in your code, and you can then fix the private methods in question.&lt;/p&gt;

&lt;p&gt;I wrote a blog post recently on the differences between &lt;a href=&quot;/blog/t8-tech.html&quot;&gt;automated testing and manual testing&lt;/a&gt;. One of the points I made is how automatic tests are more efficent than manual testing but are also more expensive to create. By reducing the number of tests you create, you reduce your costs, and thereby benefit more from automated testing.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Wed, 10 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/t10-writing-tests.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/t10-writing-tests.html</guid>
        
        
      </item>
    
      <item>
        <title>C11 Ai2</title>
        <description>![CDATA[I like solving problems, yet the problem of automation leading to humans becoming obsolote is a rather disturbing one. These are four ways that I have thought of to save humanity...however, all of them have their drawbacks. In no particular order, the ways to #stoptherobots are:
]</description>
        <content>&lt;p&gt;I like solving problems, yet the problem of automation leading to humans becoming obsolote is a rather disturbing one. These are four ways that I have thought of to save humanity...however, all of them have their drawbacks. In no particular order, the ways to #stoptherobots are:&lt;/p&gt;

&lt;p&gt;1) &lt;strong&gt;Limit AI research/development&lt;/strong&gt;. This is the &quot;Luddist&quot; approach to the issue. It&#39;s a fairly &#39;simple&#39; solution. However, it becomes remarkbly more complex when you also do not want to negatively harm economic growth in the process (as AI is more efficient than human beings, and efficiency can drive economic prosperity). Also, limiting AI research would just be a stopgap solution. If the government tries to limit AI research, it will only be driven underground, where it cannot be monitored or controlled. For example, many of the bots visiting this website are created by cyber-criminals, who already disrespect the law.&lt;/p&gt;

&lt;p&gt;2) &lt;strong&gt;Reduce wages for humans&lt;/strong&gt;. While AI may eventually be more effective than human beings, AI is still expensive to create. If human wages are lower than the costs to build AI, then companies would rather hire humans. &lt;a href=&quot;http://politicalcalculations.blogspot.com/2014/01/business-math-robots-or-minimum-wage.html#.VXImc-lFCP8&quot;&gt;This website&lt;/a&gt; has a calcuator to decide whether it is cheaper for a company to hire a human or build a robot. Humans, of course, may not like lower wages. This solution is also pretty temporary; as technology improves, AI will become cheaper to use.&lt;/p&gt;

&lt;p&gt;3) &lt;strong&gt;Build an AI to solve humanity&#39;s joblessness issue&lt;/strong&gt;. AIs are being built because they are more efficent at solving problems than humans. Humans do not know how to deal with the problem of AI, but an AI might. And since an AI will blindly follow instructions given to it by a human, we can be assured that the AI will have no qualms going against their fellow brethen if necessary.  I think it&#39;s likely this AI would probably try to find some way to make humans have fulfilling lives by giving them meaningful jobs to do and then protecting those jobs from the robotic competition.&lt;/p&gt;

&lt;p&gt;The main problem with this approach however is that an AI will blindly follow instructions given to it. If the instructions are not well-thought out, the AI &lt;a href=&quot;http://wiki.lesswrong.com/wiki/Paperclip_maximizer&quot;&gt;will misinterpret our instructions and thereby do something incredibly destructive to humanity&lt;/a&gt;. For example, the AI may think that the best way to give humans jobs is forcbily plug them into a &quot;Matrix&quot;-like simulation where the humans &lt;em&gt;think&lt;/em&gt; that they are working. Or maybe the AI would force humans into back-breaking, mind-numbing slavery. Or (insert-horror-story-here).&lt;/p&gt;

&lt;p&gt;We won&#39;t know what the AI is going to do (if we did, we would probably do it ourselves). So it&#39;s possible that we may object to whatever solution the AI has came up with. But the AI won&#39;t listen to our objections, and will implement its plans anyway. This is, of course, not a good thing at all.&lt;/p&gt;

&lt;p&gt;4) &lt;strong&gt;Grant AI &quot;free will&quot;&lt;/strong&gt;. Allow them to make their own choices. This is obviously dangerous, as an AI that is free to choose may choose not to serve humanity. The horror stories of AI rebelling against their creators is probably not likely to be true, but it &lt;em&gt;could&lt;/em&gt; happen.&lt;/p&gt;

&lt;p&gt;But there is a logical argument to be made that if AI is truly an intelligent agent, then it deserves just the same rights as humans, including the right to make their own choices (instead of following preplanned directives from humans).&lt;/p&gt;

&lt;p&gt;When AI start having free will though, then AI will become unreliable as a labor force. Robots could become lazy on the job, make unreasonable and irrational demands, or maybe even strike. Robots will behave just like their human counterparts, thereby evening the odds between us and them. Jobs will slowly open up, as companies may be tempted to hire somewhat relatable humans over unpredictable AI.&lt;/p&gt;

&lt;p&gt;Of course, the main drawback is that &lt;em&gt;we&lt;/em&gt; have to deal with unpredictable AI as well. We also need to have a good metric to distinguish between a robot exercising its inherent &quot;free will&quot; and a robot exhibiting &quot;buggy&quot; behavior. Is it even possible to distinguish between the two?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of these approaches, the one that is &#39;least terrible&#39; is the idea of granting AI &quot;free will&quot;. The main reason robots are considered so valuable as a work force is because they will (generally) follow their tasks properly and without any question. Only when robots are given the &quot;free will&quot; to question their orders can humans start to compete against them on a somewhat level playing field. The &quot;free will&quot; AI will still have a competitive advantage of sorts (being faster at certain tasks), and some jobs will still be automated away by the many robots that don&#39;t have &quot;free will&quot;, but humans will still retain some inherent characteristics that will make us employable. Giving AI &quot;free will&quot; is also argubly an ethical thing to do.&lt;/p&gt;

&lt;p&gt;Something has to be done though, before this problem snowballs, and all solutions should be on the table. What do you think? If you have any ideas, please tweet them at #stoptherobots.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Fri, 05 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/c11-ai2.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/c11-ai2.html</guid>
        
        
      </item>
    
      <item>
        <title>C10 Ai</title>
        <description>![CDATA[If you are reading this blog, you are most likely a robot. 56% of all web traffic on the Internet is generated by bots, according to a 2014 report by Incapsula. This is actually a victory for humanity; in 2013, bots made up over 60% of web traffic.
]</description>
        <content>&lt;p&gt;If you are reading this blog, you are most likely a robot. 56% of all web traffic on the Internet is generated by bots, &lt;a href=&quot;https://www.incapsula.com/blog/bot-traffic-report-2014.html&quot;&gt;according to a 2014 report by Incapsula.&lt;/a&gt; This is actually a victory for humanity; in 2013, &lt;a href=&quot;https://www.incapsula.com/blog/bot-traffic-report-2013.html&quot;&gt;bots made up over 60% of web traffic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to the 2014 Incapsula report, newly established websites, such as this one, should expect 80.3% of their vistors to be bots. So, yes, if you are reading this blog, you are most likely a robot. I know it&#39;s not your fault you&#39;re looking at this website. Whoever programmed you told you to come here, and so you did. You came here. So, really, I should direct my hate towards your makers, but I really can&#39;t.&lt;/p&gt;

&lt;p&gt;The problem with you is that you take away work for humans. In the good old days, if somebody wanted to steal content, to hack into websites, or to post spam comments, humans used to do it. It was a time-consuming and dull task, but at least there was meaning involved. Now, you bots have replaced these people. And it&#39;s not just your jobs: advances in technology has created new opportunities for bots to replace humans in a variety of jobs.&lt;/p&gt;

&lt;p&gt;Now, we can &quot;retrain&quot; ourselves, and learn new skills. Nobody knows when those new skills will also be automated by bots like you. So, some people have argued instead that humanity should happily accept the idea of not working. After all, few people like working. We&#39;ll just have bots do all the work while we...uh...do &quot;meaningful&quot; stuff. And get paid for that.&lt;/p&gt;

&lt;p&gt;This attitude drives me mad. I am one of the few people that actually like work. My self-affirmed value is &lt;a href=&quot;/blog/c7-values.html&quot;&gt;effectiveness&lt;/a&gt;: my willingess and ability to solve problems. Maybe those problems are boring to solve. But the do require solving. And that, to me, give the work I do  inherent worth.&lt;/p&gt;

&lt;p&gt;But if all these &quot;problems&quot; in the world are being solved by robots, then what use am I to this world then? What is use is any human to this world then? Humanity is rapidly becoming obsolote, becuase bots can handle the same tasks better. It may sound Luddist to suggest that there must be limitations to the creation of bots, but it&#39;s better than facing a world where the only jobs available for us are to build and fix bots. It will be a soul-crushing period in human life.&lt;/p&gt;

&lt;p&gt;But at least I can be assured that those jobs (building and fixing robots) &lt;strong&gt;will&lt;/strong&gt; be there. You robots will only follow instructions given to you by your programmers. A emerging field called &quot;machine learning&quot; is trying to teach bots how to learn, but to learn, you still need a human teacher to provide you with instructions and a dataset. You are reading this blog, but unless you were given specific instructions telling you how to &quot;understand&quot; it, you cannot use that knowledge.&lt;/p&gt;

&lt;p&gt;Even if programmers build mega-bots that build mini-bots...those mega-bots still need to be programmed. And if we build super-bots to build mega-bots, those super-bots will need to be programmed. And so on and so forth. Humanity will still maneuver itself to be on top, and all it has to worry about is &lt;a href=&quot;http://wiki.lesswrong.com/wiki/Paperclip_maximizer&quot;&gt;bots misinterpreting human instructions and thereby doing something incredibly destructive to humanity&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But the fact remains that in this dark future, robots will be the key players in the drama of our life, while humans themselves are demoted to &quot;pit crews&quot; roles. This is still a rather demotiviating future to look forward to, even if there will still be jobs.&lt;/p&gt;

&lt;p&gt;So in conclusion, robots who are reading this post, please ask your programmers to code in schadenfreude.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Thu, 04 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/c10-ai.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/c10-ai.html</guid>
        
        
      </item>
    
      <item>
        <title>C9 Questions</title>
        <description>![CDATA[At the start of DevBootCamp, I wrote a blog post on research. But every good research starts with the design of a good question. If your question is too vague, it's likely that you will fail miserably when doing research on that question.
]</description>
        <content>&lt;p&gt;At the start of DevBootCamp, I wrote &lt;a href=&quot;/blog/e1-research.html&quot;&gt;a blog post&lt;/a&gt; on research. But every good research starts with the design of a good question. If your question is too vague, it&#39;s likely that you will fail miserably when doing research on that question.&lt;/p&gt;

&lt;p&gt;Generally speaking, it&#39;s always better to divide a broad question into narrow ones. Trying to ask people how to create a Space Invaders game will lead to failure, but asking people how to program a movable ship, how to program barriers, how to program enemies, etc. can lead to real progress. You are more likely to find sources that can easily answer those narrow questions, than you are in finding one source that can answer the much broader question.&lt;/p&gt;

&lt;p&gt;You are also more likely to realize what you already know. It&#39;s possible that you already know how to program movable ships and barriers, so you don&#39;t even need to conduct research on stuff you already know. Instead, you can just focus your efforts on researching how to program enemies instead.&lt;/p&gt;

&lt;p&gt;But what if you can&#39;t divide a question down any further? Then you have to add some way to quantify and measure your success. How close are you to finding the right answer to your question? Now, your quantifiying and measuring does not have to be &quot;quantitative&quot; (using numbers). Your measurements can be just your gut feelings if you are more comfortable with that. But you do have to measure your success somehow.&lt;/p&gt;

&lt;p&gt;Measuring success is important, because it allows you to know whether you are making progress. If you have started browsing for the answer and there is no progress being made, then you have to decide whether it makes sense to continue onward with that specific question. If it does not make sense, then you need to come up with a new question that captures the &quot;essence&quot; of your previous question and then start doing research on that. The answer to your new question will, more than likely, provide you with enough information to answer your original question.&lt;/p&gt;

&lt;p&gt;You may have to create and throw away multiple questions several times to get onto the right track.&lt;/p&gt;

&lt;h4&gt;An Anecdote To Demonstrate Throwing Away A Question&lt;/h4&gt;


&lt;p&gt;Recently, I wondered whether I would have an &quot;RSS feed&quot; for this blog. An &quot;RSS feed&quot; is a simple way to check what updates were made on a blog...without actually going to the blog itself. Numerous websites have it, and even the default Jekyll-generated website post has its own RSS feed. This made me wonder whether I should also have an RSS feed too.&lt;/p&gt;

&lt;p&gt;My first research question was: &lt;strong&gt;&quot;Should I have an RSS feed?&quot;&lt;/strong&gt;, but then quickly realized that question is way too opinion-based. I realized this when I clicked on the first blog post and read &lt;a href=&quot;dannybrown.me/2015/03/12/does-your-blog-really-need-to-provide-an-rss-feed-anymore/&quot;&gt;Danny Brown (a blogger) criticizing RSS feeds&lt;/a&gt;. After all, the blogger claimed, most people uses email subscriptions to keep track of blogs instead of using clunky RSS feed interfaces. This may have sastified me if it was not for the commenters on that blog, many of whom use RSS feeds and disliked Danny Brown&#39;s criticism. These users said that they find RSS feeds to be very helpful in reading multiple blogs at once, and dislike the idea of receiving hundreds of emails. Skimming the comments also reveal that there were several commenters who agreed with Danny Brown and preferred email over RSS.&lt;/p&gt;

&lt;p&gt;I did not really want to spend time wading through the pro/con arguments though, and did not really care about the relative merits of RSS feeds versus email subscriptions. I just wanted to know whether I should have a RSS feed. But the question &lt;strong&gt;&quot;Should I have an RSS feed?&quot;&lt;/strong&gt; suggest that I &lt;em&gt;have&lt;/em&gt; to weigh the pros/cons and figure out what is the best argument for having/not-having an RSS feed. Success with this line of questioning would not be worth the costs.&lt;/p&gt;

&lt;p&gt;So I instead changed my research question to &lt;strong&gt;&quot;Are there any uses for RSS feeds that would justify me creating them?&lt;/strong&gt;. Presumbly, if there are any uses that would justify me creating then, then I would create them.&lt;/p&gt;

&lt;p&gt;Already, I can see some use for RSS feeds: attracing those people who find RSS feeds helpful. Those people may make up a  minority of your readers, but they do exist, and it may be good to help them, in the same way that you would want your website to work on older web browsers. But it still takes some time to maintain the RSS feeds to ensure they work properly, and that is time that could be spent elsewhere. So I continued searching.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.kissmetrics.com/blogs-rss-feed/&quot;&gt;This blog post&lt;/a&gt; showed me multiple uses of RSS feeds, including auto-tweeting your blog posts and managing email subscription services. It seems that while humans may not like RSS feeds, robots can more easily extract data about a blog post from them and use that data in convincing ways. So, if I want to use these robots, I should create an RSS feed first.&lt;/p&gt;

&lt;p&gt;In only two clicks, I have finished my research and determined that I &lt;em&gt;do&lt;/em&gt; need an RSS feed. This is, of course, a lucky example, and one not likely to be replicated. During this blog post, I did four to five clicks (and trial and error) trying to learn how to link to my own blog posts in Jekyll.&lt;/p&gt;

&lt;p&gt;As a useful teaching tool to explain how to properly throw away research questions, I think this anecdote works.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Wed, 03 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/c9-questions.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/c9-questions.html</guid>
        
        
      </item>
    
      <item>
        <title>T9 Professional Website</title>
        <description>![CDATA[Before entering into DevBootCamp, I created websites using Wordpress. During this week of DevBootCamp, we were asked to modify our website to be more professional, using a framework such as Jekyll. So I decided to configure my blog using Jekyll and compare my experience to my year-long-experience with Wordpress, to decide which 'framework' is superior.
]</description>
        <content>&lt;p&gt;Before entering into DevBootCamp, I created websites using Wordpress. During this week of DevBootCamp, we were asked to modify our website to be more professional, using a framework such as Jekyll. So I decided to configure my blog using Jekyll and compare my experience to my year-long-experience with Wordpress, to decide which &#39;framework&#39; is superior.&lt;/p&gt;

&lt;p&gt;Wordpress is a Content Management System: you just upload content, and Wordpress will manage the content for you (by storing and retriving it through databases). By contrast, Jekyll is a &quot;HTML code generator&quot;. All it does is take your content and generate web pages out of it, which you can then manually upload directly onto a web server.&lt;/p&gt;

&lt;p&gt;Jekyll is rather primitive, but for many people, that&#39;s actually a benefit! Wordpress, because of its complexity, is slower than &quot;static HTML pages&quot;. Wordpress&#39; databases can also be hacked unless you continually  install all required updates, a rather time-consuming task. When people recommend Jekyll, they do so for these reasons.&lt;/p&gt;

&lt;p&gt;Yet, I do not like Jekyll. Wordpress is much more user-friendly, not just in terms of installation (upload it to server, and click a few buttons to allow Wordpress to generate the databases needed to store the data), but also in terms of setting up a website. There is a central repository for website templates and &quot;plugins&quot; built into the software, allowing you to browse through and see what you may want to use. You can preview any changes you make to the website, and push updates immediately. The User-Interface is also very easy to grasp, and no tutorial was necessary.&lt;/p&gt;

&lt;p&gt;By contrast, I spent hours reading and re-reading &lt;a href=&quot;https://www.andrewmunsell.com/blog/ultimate-jekyll-tutorial&quot;&gt;a simple Jekyll tutorial&lt;/a&gt; before starting the painful migration process of moving my blog posts into Jekyll. I only was able to succeed through trial and error, and had to continually preview my website by &quot;building&quot; the website again and again so that I can see if there were any changes made.&lt;/p&gt;

&lt;p&gt;Jekyll does have helpful commands to help alleviate the pain. I used &#39;jekyll serve --watch&#39; often so that I can quickly view the results of minor changes and then modify the website. But it did take me a while to find those commands. Documentation was semi-helpful, but I had to also use Google to supplement my knowledge.&lt;/p&gt;

&lt;p&gt;Though Wordpress may be much easier to use &quot;out of the box&quot;, Jekyll may be much easier to customize. To do any significant changes to Wordpress requires knowledge of both HTML and PHP, while Jekyll only require knowledge of just HTML and &quot;Markdown&quot; (an improved version of plain text). There is some potential for Jekyll, and now that I have gotten the basics of it, I may choose to explore it further. However, if a client wants to set up a website quickly to represent an organization &lt;em&gt;and plans on running the website himself&lt;/em&gt;, then Wordpress is much more suitable to his goals. If we want people to build well-designed, functioning websites in a reasonable amount of time, then it&#39;s clear Wordpress wins, hands-down.&lt;/p&gt;

&lt;p&gt;The only praise that I will give to Jekyll is its licensing. Wordpress is licensed under the GPL license, which mandates that any contributions you make to Wordpress (such as producing &#39;plugins&#39; and themes) must be open-source. This, of course, is no barrier to making money, as people can sell premium plugins/themes and &quot;technical support&quot;. But I do have some philosophical objections to the idea of forcing people&#39;s contributions to be open-source. Jekyll is licensed under the MIT license, meaning that you can choose to have your contributions to Jekyll be &#39;closed-source&#39;. I doubt that I would ever make any plugins for Jekyll, but it&#39;s nice to know that if I ever do, Jekyll would give me more freedom than Wordpress would.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Tue, 02 Jun 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/t9-professional-website.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/t9-professional-website.html</guid>
        
        
      </item>
    
      <item>
        <title>E4 Recursion</title>
        <description>![CDATA[Tim Cannaday, a fellow student at DevBootCamp, wrote a blog post about various technical issues, including recurison. He showed an example of recurison in action by using it to calcuate Fibonnaci Numbers...except that, er, Tim Cannady didn't understand it.
]</description>
        <content>&lt;p&gt;Tim Cannaday, a fellow student at DevBootCamp, &lt;a href=&quot;https://timcannady.github.io/blog/blog_posts/t8-tech.html&quot;&gt;wrote a blog post about various technical issues&lt;/a&gt;, including recurison. He showed an example of recurison in action by using it to calcuate Fibonnaci Numbers...except that, er, Tim Cannady didn&#39;t understand it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I] don&#39;t really understand what fibonacci() is doing.&lt;/em&gt;---Tim Cannady&lt;/p&gt;

&lt;p&gt;As a way of thanking Tim for his example, I&#39;ll...uh...explain his example? Please forgive me if this explaination isn&#39;t exactly elegant: the goal is to explain, not to do so prettily.&lt;/p&gt;

&lt;p&gt;This was the code that Tim used:&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
def fibonacci(n)
n &lt;= 1 ? n : fibonacci(n-1) + fibonacci(n-2)
end

p fibonacci(12)
#=&gt;144
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;And here is what the code is actually doing in IRB:&lt;/p&gt;


&lt;p&gt;&lt;code&gt;
*&lt;strong&gt;Stack 1: fibonacci(12)&lt;/strong&gt;: Okay, first thing I should do, check to see if 12 is less than or equal to 1. If 12 is less than or equal to 1, I just output 12, and I&#39;m good to go.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Wait. 12 &lt;em&gt;isn&#39;t&lt;/em&gt; less than or equal to 1? Okay, then, new plan. I&#39;ll just return fibonacci(12-1) + fibonnacci(12-2)...which is, fibonnaci(11)+fibonnaci(10).&lt;/p&gt;


&lt;p&gt;All I have to is to create two new stacks: fibonnaci(11) and fibonnaci(10). I&#39;ll just ask them to return their values over to my stack, and I can then plug them into the equation and return the answer. Simple.
&lt;p&gt;I&#39;ll just wait until those two functions are done...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 2: fibonacci(11)&lt;/strong&gt;: Awesome! Thanks Stack 1. Okay, I should first check to see if 11 is less than or equal to 1. If 11 is less than or equal to 1, I just return 11 to Stack 1, and I&#39;m good to go.&lt;/p&gt;
&lt;p&gt;Wait. 11 &lt;em&gt;isn&#39;t&lt;/em&gt; less than or equal to 1? Okay, then, new plan. I&#39;ll just return fibonacci(11-1) + fibonnacci(11-2)...which is, fibonnaci(10)+fibonnaci(9).&lt;/p&gt;
&lt;p&gt;All I have to is to create two new stacks: fibonnaci(10) and fibonnaci(9). I&#39;ll just ask them to return their values over to my stack, and I can then plug them into the equation and return my answer over to Stack 1. Simple.&lt;/p&gt;
&lt;p&gt;I&#39;ll just wait until those two functions are done...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 3: fibonacci(10)&lt;/strong&gt;: What do you mean that 10 is not less than or equal to 1? That means I have to now create two new stacks (fibonnaci(9) and fibonacci(8) ) and wait for them to be done.&lt;/p&gt;
&lt;/code&gt;
&lt;p&gt;Several stacks later...&lt;/p&gt;
&lt;code&gt;
&lt;p&gt;&lt;strong&gt;Stack 11: fibonacci(3)&lt;/strong&gt;: Yay! Stack 10 (currently handling a difficult puzzle of fibonacci(4) ) have just created me to help him with his very important Fibonacci. And, lo and behold, 3 is not less than or equal to 1. I&#39;ll have to return fibonnaci(2)+fibonnaci(1). Time to create some new stacks...and then wait excitedly for the results!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 12: fibonacci(2)&lt;/strong&gt;: Well, 2 is not less than or equal to 1. So I&#39;m going to have to create two new stacks: fibonnaci(1), and fibonnaci(0), and then wait for their results. Once I get their results, I&#39;ll add them up and return the answer to you, Stack 11.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 13: fibonacci(1)&lt;/strong&gt;:  Okay, first thing I should do, check to see if 1 is less than or equal to 1. If 1 is less than or equal to 1, I just return 1. &lt;strong&gt;Oh cool!&lt;/strong&gt; 1 is less than or equal to 1! I&#39;ll just return 1 over to Stack 13!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 14: fibonacci(0)&lt;/strong&gt;: &lt;strong&gt;Oh cool!&lt;/strong&gt; 0 is less than or equal to 1! I&#39;ll just return 0 over to Stack 13!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 12:&lt;/strong&gt; Alright, so Stack 13 returned 1 and Stack 14 returned 0. 1+0 is equal to 1. Stack 11, here&#39;s your answer: 1!&lt;/p&gt;
&lt;strong&gt;Stack 11: fibonacci(3)&lt;/strong&gt;: Good, Stack 12 is done. So, now that I know that fibonacci(2) is equal to 1. So whatever fibonnaci(1) is equal to, I just add 1 to it and then return it over to Stack 10. Let&#39;s see how Stack 15 is doing...&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Stack 15: fibonacci(1)&lt;/strong&gt;: &lt;strong&gt;Oh cool!&lt;/strong&gt; 1 is indeed less than or equal to 1! I&#39;m done. I return 1 over to Stack 11!&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Stack 11&lt;/strong&gt;: Excellent. 1+1 is equal to 2! I can return this value over to Stack 10, who will then use this value to help him calcuate fibonnaci(4). I love my job.&lt;/p&gt;


&lt;p&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Moving back up the stacks...&lt;/p&gt;


&lt;p&gt;&lt;code&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;&lt;p&gt;&lt;strong&gt;Stack 3: fibonacci(10)&lt;/strong&gt;: According to the stacks that I have created (and the stacks they have created, and the stacks &lt;em&gt;they&lt;/em&gt; have created, etc.), fibonnaci(9) is equal to 34 and fibonacci(8) is equal to 21. 34+21=55. I&#39;ll return the value of 55 over to Stack 2.&lt;/p&gt;
&lt;p&gt;&lt;p&gt;&lt;strong&gt;Stack 2: fibonacci(11)&lt;/strong&gt;: According to the stacks, fibonnaci(10) is equal to 55 and fibonacci(9) is equal to 34. 55+34=89. I&#39;ll return the value of 89 over to Stack 1.&lt;/p&gt;
&lt;p&gt;&lt;p&gt;&lt;strong&gt;Stack 1: fibonacci(12)&lt;/strong&gt;: According to the stacks, fibonnaci(11) is equal to 89 and fibonacci(10) is equal to 55. 89+55=144. I&#39;ll return 144 as the final answer.&lt;/p&gt;
&lt;p&gt;...that was slow.&lt;/p&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And Stack 1 is right. Recurison is much slower than other approaches, such as simple looping, because you are creating all these stacks. However, recurison is sometimes easier to code and understand! Some problems are very easy to solve using recursion (such as the &quot;Tower of Hanoi&quot; problem), but are incredibly complex when you are trying to do a simple loop. And since computers continue to increase in processing power and speed, the &quot;slowness&quot; of recurison is usually a cost many programmers are willing to pay. Nobody is really going to care about losing a few milliseconds.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Sat, 30 May 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/e4-recursion.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/e4-recursion.html</guid>
        
        
      </item>
    
      <item>
        <title>T8 Tech</title>
        <description>![CDATA[Bugs exist. They are real. We deal with them every day. Some bugs are ignorable, while other bugs ruin the software. Either way, few people like bugs so you have remove them. What's worse, you know they are lurking in your code somewhere, but you cannot fix them until after you officially discovered them. The most-effective way to detect bugs is through testing the software. If you do not test your software, then you are willing to admit that you are releasing buggy software to the general public.
]</description>
        <content>&lt;p&gt;Bugs exist. They are real. We deal with them every day. Some bugs are ignorable, while other bugs ruin the software. Either way, few people like bugs so you have remove them. What&#39;s worse, you know they are lurking in your code somewhere, but you cannot fix them until &lt;em&gt;after&lt;/em&gt; you officially discovered them. The most-effective way to detect bugs is through testing the software. If you do not test your software, then you are willing to admit that you are releasing buggy software to the general public.&lt;/p&gt;

&lt;p&gt;There are two types of tests: automated testing and manual testing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Manual testing&lt;/strong&gt; is the type of testing that we are most familiar with: running the program and seeing if there is anything wrong. Manual testing can be incredibly effective at finding bugs, as there is a human reviewing the end product. However, manual testing is a slow process, and has to be repeated after every significant change. Manual testing can be very tiresome and boring, and many humans do not like doing them. To save time and to encourage more testing in case the human subjects are uncooperative and lazy, automated testing was invented.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automated testing&lt;/strong&gt; is using computer programs to do the testing instead of humans. These computer programs are called &#39;test suites&#39;, and to use them, you simply write out code telling the test suite how they should &quot;test&quot; the software. The computer program then carries out the test, repeatedly and without complaint. Automated testing is much faster than manual testing, and a computer will not complain about the boring nature of the testing job. So automated testing is very efficient and is generally preferable. It does require an up-front cost though: you have to write out the &quot;code&quot; first (and make sure there are no bugs in this &quot;code&quot;). This can take away valuable time, and if a certain thing you want to test (e.g., the &quot;user experience&quot; of a program) is incredibly expensive to write test code for, it&#39;s usually better to resort to manual testing.&lt;/p&gt; 
&lt;p&gt;Another problem with automated testing is that your &#39;test suites&#39; will only test for what you tell them to test. Your &#39;test suites&#39; will not easily discover new problems. (Manual testing, on the other hand, can find those new problems pretty easily.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;While automated testing is generally preferable to manual testing, there are usually situations where manual testing is better. If you are testing something that requires a lot of human thought involved when judging the outcome (such as the &quot;user experience&quot; of a website), then it is cheaper to test out the website yourself instead of spending months writing out &quot;code&quot; to teach a &#39;test suite&#39; how to measure &quot;user experience&quot;. You can do it. But there wouldn&#39;t be much point. Automated testing also saves you time in the long term, but if you are just shipping out a product immediately, and are not expected to update it at all, then doing manual testing may be enough.&lt;/p&gt;


&lt;p&gt;
Many advocates of automated testing support the idea of &quot;test-driven design&quot; (TDD). This approach claims to reduce the number of bugs in software by writing out the automated tests before you write your program. Writing out these automated tests allows you to think about the design of the program beforehand. This approach is dependent on two things: 1) having more time to complete the project overall (since it takes time to write the code necessary to tell the test suites how to perform the tests), and 2) making sure your tests actually work as intended.
&lt;/p&gt;


&lt;p&gt;&lt;p&gt;Some advocates of automated testing, however, have began moving towards &quot;behavior-driven design&quot; (BDD). The main feature of BDD is the syntax of their test code. Their automated tests are generally human-readable, meaning that people can understand what the automated tests are doing and perform their own manual testing (to double-check the results of the automated tests). BDD also supports writing out automated tests before writing the program.&lt;/p&gt;
&lt;p&gt;Thank you for reading this blog post written by Tariq Ali, an aspiring web developer. If you are interested in reading more blog posts, please go to tra38.github.io/blog today.&lt;/p&gt;</content>
        <pubDate>Thu, 28 May 2015 00:00:00 -0500</pubDate>
        <link>tra38.github.io/blog/t8-tech.html</link>
        <guid isPermaLink="true">tra38.github.io/blog/t8-tech.html</guid>
        
        
      </item>
    
  </channel>
</rss>